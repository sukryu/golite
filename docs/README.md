# README.md

## 🌟 GoLite: 까리함의 끝판왕, SQLite 1.0을 현대 아키텍처와 Lock‑Free 혁신으로 재탄생! 🌟

안녕하세요! 👋  
여긴 **GoLite**의 세계예요—저의 손으로 SQLite 1.0을 Go로 재창조하면서, DDD, 헥사고날 아키텍처, 이벤트 기반, CQRS와 함께 최신 Lock‑Free 기술까지 도입해 단순 복제를 넘어 혁신적인 DB로 발전시킨 프로젝트예요.  
이제 GoLite는 기존 SQLite 1.0의 뿌리를 그대로 두면서, 동시성 성능과 확장성을 극대화한 클라우드 네이티브 DB로 거듭났습니다. 준비됐나요? Let’s GoLite! 🚀✨

---

## 🎯 목표: 5단계로 쌓아가는 까리함의 여정

GoLite는 다음의 5단계로 진화합니다. 각 단계마다 기존 시스템을 현대화하고, 최신 동시성 기술(특히 lock‑free 자료구조)을 도입하여 극한의 성능과 안정성을 구현합니다.

### 1단계: SQLite 1.0을 DDD & 헥사고날로 재구성 🛠️
- **무엇?**: SQLite 1.0의 테이블, 인덱스, B-트리를 도메인 모델로 변환하고, 헥사고날 포트/어댑터로 분리  
- **왜?**: 저장소를 추상화하여 인터페이스 기반의 모듈 분리 및 교체를 쉽게 함  
- **까리함**: "25년 전 DB를 DDD로 리믹스!" 💾

### 2단계: 이벤트 기반 CQRS로 쓰기/읽기 분리 📈
- **무엇?**: 삽입/삭제를 이벤트로 처리하고, 읽기와 쓰기를 완전히 분리  
- **왜?**: 비동기성과 성능 최적화를 통해 SQLite의 한계를 극복  
- **까리함**: "쿼리가 이벤트로 춤춰요!" 🌍

### 3단계: LSM Tree 및 Lock‑Free MemTable 도입 🌳
- **무엇?**: B‑트리 대신 LSM Tree로 전환하고, MemTable은 기존 뮤텍스 기반 대신 lock‑free skip list 기반으로 재구현  
- **왜?**: Go의 동시성 강점을 최대한 활용하여 쓰기와 읽기 성능을 극대화  
- **까리함**: "RocksDB 스타일에 Lock‑Free 혁신까지, GoLite 탄생!" 💃  
- **동시성 해결 전략**:  
  - **Atomic 연산 도입**: 메트릭, MemTable 크기 업데이트 등에서 `sync/atomic`을 활용  
  - **Lock‑Free 자료구조 설계**: 인터페이스 분리를 통해 기존 구현체와 lock‑free 구현체를 쉽게 교체  
  - **ABA 문제 및 메모리 회수**: hazard pointer 또는 epoch‑based reclamation 기법 도입(추후 확장)

### 4단계: Goroutines를 이용한 병렬 처리 폭발 ⚡
- **무엇?**: Go의 goroutines를 활용하여 이벤트와 쿼리를 병렬로 처리  
- **왜?**: 높은 동시성과 낮은 레이턴시를 실현하여 실시간 시스템에 걸맞은 성능을 보장  
- **까리함**: "Go의 힘으로 멀티코어 점령!" 🧵

### 5단계: gRPC/REST API로 클라우드 네이티브화 ☁️
- **무엇?**: gRPC와 REST API를 통해 클라우드 환경에서 쉽게 배포 및 운영 가능한 경량 DB를 완성  
- **왜?**: 백엔드 엔지니어의 꿈을 현실로, 실무 적용 및 클라우드 네이티브 환경 구축  
- **까리함**: "클라우드 위의 힙한 GoLite!" ✈️

---

## 💡 왜 GoLite가 까리하냐고요?
- **혁신과 차별성**: SQLite 1.0의 전통을 계승하면서도 DDD, 헥사고날, 이벤트 기반, CQRS, 그리고 최신 lock‑free 동시성 기술을 결합해 독보적인 DB를 만들어냈어요.  
- **동시성 혁신**: 기존 락 기반 설계에서 벗어나, atomic 연산과 lock‑free 자료구조를 도입해 극한의 동시성과 성능을 달성했습니다.  
- **미래지향적 설계**: 인터페이스 기반 모듈 분리로 생산 환경에서 쉽게 교체, 확장, 유지보수가 가능하며, Kubernetes 스타일의 클라우드 네이티브 운영이 가능합니다.  
- **힙함**: "GoLite"라는 이름에 Go의 간결함과 혁신적인 DB 디자인, 그리고 까리한 엔지니어 정신이 담겨 있답니다. ㅋㅋㅋ

---

## 🏛️ 아키텍처: SQLite 1.0 meets 현대 디자인 & Lock‑Free 혁신
GoLite는 전통적인 SQLite 1.0의 뼈대를 유지하면서도, 다음과 같은 최신 기술들을 접목했습니다:

- **DDD & 헥사고날 아키텍처**  
  `Table`, `Index`, `Database`를 도메인 모델로 재정의하고, 포트/어댑터 패턴을 적용하여 각 구성요소를 독립적으로 교체할 수 있도록 했습니다.

- **이벤트 기반 & CQRS**  
  쓰기와 읽기 로직을 명확히 분리해, 비동기 이벤트 핸들링과 서비스 경계를 확실히 했습니다.

- **Lock‑Free 자료구조 도입**  
  LSM Tree를 기반으로 한 저장소 설계와 함께, MemTable은 기존의 뮤텍스 기반 구조 대신 lock‑free skip list(atomic 연산과 CAS, 태깅 기법 활용)로 재구현하여 동시성 및 성능을 극대화했습니다.

- **모듈 분리 및 인터페이스 기반 설계**  
  MemTable, WAL, SSTable, 캐시, 컴팩터 등의 각 구성요소를 독립된 인터페이스로 정의하여, lock‑free 구현체와 기존 구현체를 쉽게 교체할 수 있도록 했습니다.

- **Kubernetes 스타일 운영**  
  구조화된 로깅, 명확한 모듈 경계, CI/CD 및 클라우드 네이티브 배포 전략을 통해, 실제 운영 환경에서도 안정적이고 효율적으로 동작하도록 설계되었습니다.

---

## 🛠️ 진행 상황
- [x] SQLite 1.0 소스코드 분석 (Fossil로 확보)  
- [x] 1단계: DDD & 헥사고날 기반 SQLite 1.0 재구성  
- [x] 2단계: 이벤트 기반 CQRS 적용  
- [ ] 3단계: LSM Tree 전환 및 Lock‑Free MemTable 도입 (현재 개발 진행 중)  
- [ ] 4단계: Goroutines를 이용한 병렬 처리 최적화  
- [ ] 5단계: gRPC/REST API를 통한 클라우드 네이티브 배포  

---

## 🚀 GoLite 띄우기
1. **도메인 정의**: `pkg/domain/`에서 SQLite 1.0의 전통적인 구조를 가져옵니다.  
2. **어댑터 연결**: `pkg/adapters/lockfree/` 내의 lock‑free MemTable 및 기타 모듈로 시스템을 구성합니다.  
3. **실행**:  
```bash
go run cmd/golite/main.go
```
   로 까리함을 확인하세요!

---

## 🌈 GoLite Performance & Concurrency Evolution
GoLite는 성능 및 동시성 최적화를 위해 다음과 같은 단계를 거쳤습니다:

- **기존**: SQLite 1.0 기반의 단순 구조  
- **1단계**: Append‑Only Log + WAL 도입 → I/O 오버헤드 감소  
- **2단계**: Buffered Writing 도입 → 버퍼링으로 호출 횟수 및 할당량 대폭 감소  
- **3단계**: Background Writing 및 Lock‑Free, 비동기 최적화 적용 → 동시성에서 안정적인 성능 확보  
- **4단계**: Binary Serialization 및 Compaction 최적화 → JSON 오버헤드 제거, 삽입 성능 향상  
- **5단계**: In‑Memory Index & Get 최적화 → `sync.Map` 기반 O(1) 조회 도입, 읽기 성능 극대화  
- **동시성 해결**: Atomic 연산, CAS 루프, 그리고 lock‑free 설계를 통해, 기존 락 기반 구조의 병목을 제거하였습니다.  
  - **예시**: MemTable의 크기 업데이트, 인터페이스 분리, 그리고 노드 삽입/삭제에서 lock‑free 기법 적용.

---

## 📚 인터페이스 & 모듈 분리
GoLite는 주요 구성요소들을 독립된 인터페이스로 추상화하여 설계되었습니다:
- **MemTableStorage**: 인메모리 데이터 저장소의 기본 동작(삽입, 조회, 삭제, 덤프, 스왑, 리셋)을 정의합니다.
- **WALInterface**: Write-Ahead Log의 Append, Flush, Reset, Close 등을 추상화합니다.
- **SSTableInterface**: 디스크 기반 정렬 테이블의 조회, 길이, 무결성 검사, Close 등을 정의합니다.
- **CacheInterface**: 키‑값 캐시의 Get, Put, Length, Clear 등을 제공합니다.
- **CompactorInterface**: 백그라운드 컴팩션 작업을 수행합니다.

이러한 인터페이스 기반 설계 덕분에, 각 모듈을 향후 lock‑free 구현체로 쉽게 교체하거나 확장할 수 있습니다.

---

## 🎉 만든 사람
- **Jinhyeok**: Go와 아키텍처를 사랑하는 까리한 엔지니어 🌟  
- 모토: "소프트웨어는 재미있어야 까리하다!" 😊

---

GoLite는 이제 SQLite 1.0의 전통을 넘어, 현대적인 동시성 혁신(atomic, lock‑free, 인터페이스 분리)을 통해 성능과 확장성을 극대화한 미래지향적 DB로 거듭납니다.  
동시성 문제 해결을 위해 우리는 atomic 연산, CAS 루프, 그리고 lock‑free 자료구조로의 전환 등 다양한 기법을 도입했으며, 이를 통해 Go의 고루틴과 클라우드 네이티브 환경에서도 안정적이고 빠른 동작을 보장합니다.

이 까리한 여정에 동참하고 싶다면, 언제든 아이디어와 기여를 환영합니다! 🙌

---

이제 GoLite는 기존 SQLite 1.0 기반에서 벗어나, 최신 Lock‑Free 기술과 인터페이스 기반 설계를 도입한 최첨단 DB로 도약합니다.  
계속 발전하는 여정에 함께 해주세요!