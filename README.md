# README.md

## 🌟 GoLite: 세상에서 제일 까리한 나만의 데이터베이스 🌟

안녕하세요! 👋 여긴 **GoLite**의 세계예요—제가 SQLite 1.0을 Go로 재창조하면서, LSM Tree, T-Tree, goroutines로 무장한 "최강 까리한 DB"를 만드는 여정이 담겨 있어요. 학부생 과제? 그딴 건 아니에요. 이건 **저만의 소프트웨어**를 만드는 꿈의 무대예요! 💪 Go의 힘으로 클라우드와 실시간성을 뽑아내는, 세상에 하나뿐인 DB를 목표로 달려갑니다. 준비됐죠? Let’s GoLite! 🚀✨

---

## 🎯 목표: 5단계로 쌓아가는 까리함의 탑

GoLite는 5단계로 점진적으로 까리함을 극대화해요. 저의 엔지니어 꿈(백엔드, 클라우드, 실시간 시스템)을 담아, 재미와 도전을 더했어요! 🔥

### 1단계: SQLite 1.0을 Go로 완벽 복제 🛠️
- **무엇?**: SQLite 1.0을 Go로 옮겨 B-트리 기반의 클래식 DB를 재현!  
- **왜?**: 원본을 Go로 부활시키며 GoLite의 첫걸음을 내딛어요.  
- **까리함**: "25년 된 DB를 Go로 리믹스!" 💾  
- **할 일**: `sqlite.h` → `golite.go`, `btree.c` → `btree.go`, 쿼리 테스트.  

### 2단계: B-트리 → LSM Tree로 쾌속 업글 📈
- **무엇?**: B-트리를 LSM Tree로 바꿔 쓰기 성능과 클라우드 파워 업!  
- **왜?**: 순차 쓰기로 디스크를 날리고, 현대적인 터치를 더해요.  
- **까리함**: "GoLite가 RocksDB 느낌을 입었어요!" 🌍  
- **할 일**: LSM Tree의 MemTable/SSTable 구현, 쿼리 로직 조정.  

### 3단계: T-Tree로 하이브리드 GoLite 완성 🌳
- **무엇?**: T-Tree를 얹어 실시간성과 메모리 효율성을 챙긴 LSM+T-Tree 콤보!  
- **왜?**: 빠른 쿼리와 영속성을 동시에 잡는 독보적인 DB로!  
- **까리함**: "메모리와 디스크가 손잡고 춤춰요!" 💃🕺  
- **할 일**: T-Tree 캐시 추가, LSM과 동기화 로직 구현.  

### 4단계: Goroutines로 병렬 GoLite 폭발 ⚡
- **무엇?**: Go의 goroutines로 쿼리를 멀티스레드 처리!  
- **왜?**: 실시간 시스템에 걸맞게 속도를 터보로 끌어올려요.  
- **까리함**: "GoLite가 멀티코어로 날아다녀요!" 🧵  
- **할 일**: `Exec`에 goroutines 적용, 동시성 관리(채널 활용).  

### 5단계: gRPC/REST API로 클라우드 GoLite化 ☁️
- **무엇?**: gRPC와 REST API를 붙여 클라우드에서 빛나는 경량 DB로!  
- **왜?**: 백엔드 엔지니어의 꿈을 현실로, 배포 가능한 DB 완성.  
- **까리함**: "클라우드 위를 나는 GoLite, 힙해요!" ✈️  
- **할 일**: gRPC 엔드포인트 설계, REST 서버 띄우기.  

---

## 💡 왜 GoLite가 까리하냐고요?
- **유니크함**: SQLite에서 시작했지만, LSM Tree와 T-Tree로 재탄생한 나만의 DB예요! 🌍  
- **도전의 아이콘**: 따라 하는 게 아니라, 새로운 길을 개척했어요. 💪  
- **재미 폭발**: "하고 싶어서" 만든 프로젝트, 열정이 다르죠! 😎  
- **이름부터 까리**: "GoLite"라는 이름 자체가 힙하고 쿨해요. ㅋㅋㅋ  

---

## 🛠️ 진행 상황
- [x] SQLite 1.0 소스코드 겟! (Fossil로 쿨하게 다운받음)  
- [ ] 1단계: Go로 SQLite 1.0 복제  
- [ ] 2단계: LSM Tree로 업글  
- [ ] 3단계: T-Tree 하이브리드 완성  
- [ ] 4단계: Goroutines 병렬 처리  
- [ ] 5단계: gRPC/REST 클라우드화  

---

## 🚀 GoLite 띄우기
1. **소스 준비**: `src` 폴더에서 `sqlite.h`, `btree.c` 열기.  
2. **Go로 출발**: `golite.go`에 `Open`부터 써보세요!  
3. **테스트**: "INSERT" 한 번 날려보고 까리함 확인.  

```bash
go run cmd/golite/main.go
```

---

## 📂 초기 디렉토리 구조: 까리함의 설계도! 🗂️

GoLite는 깔끔하고 확장 가능한 구조로 시작해요. Go의 관례를 따르며, 5단계 목표를 쿨하게 담을 준비를 했어요! 🌟

```
GoLite/
├── cmd/                  # 까리한 실행 파일 모음
│   └── golite/           # GoLite의 메인 진입점
│       └── main.go       # DB 띄우는 쿨한 시작점 🚀
├── pkg/                  # 재사용 가능한 까리한 패키지들
│   ├── golite/           # GoLite 핵심 로직 (1단계)
│   │   ├── golite.go     # DB 인터페이스와 기본 구현
│   │   ├── btree.go      # 초기 B-트리, 클래식 스타일 💾
│   │   └── golite_test.go # 테스트로 까리함 검증
│   ├── lsm/              # LSM Tree의 힙한 공간 (2단계)
│   │   └── lsm.go        # LSM Tree 구현
│   └── ttree/            # T-Tree의 쿨한 영역 (3단계)
│       └── ttree.go      # T-Tree 구현
├── internal/             # 내부 비밀 무기 🔥
│   └── storage/          # 디스크 I/O 관리
│       └── storage.go    # 파일 읽기/쓰기 로직
├── api/                  # 클라우드 꿈의 무대 (5단계)
│   ├── proto/            # gRPC의 까리한 정의
│   │   └── golite.proto  # .proto 파일
│   └── rest/             # REST API의 힙한 핸들러
│       └── handler.go    # REST 엔드포인트
├── test/                 # 통합 테스트로 완벽 체크
│   └── integration_test.go # 전체 기능 테스트
├── go.mod                # Go 모듈, 의존성 관리의 시작
├── go.sum                # 체크섬으로 깔끔하게
├── README.md             # 이 까리한 문서! ✨
└── Makefile              # 빌드/테스트 단축키 (선택)
```

### 구조 설명
- **`cmd/`**: GoLite를 실행하는 쿨한 진입점이에요. `main.go`에서 DB를 띄워요!  
- **`pkg/`**: GoLite의 심장! `golite`는 1단계, `lsm`과 `ttree`는 2~3단계를 위한 공간.  
- **`internal/`**: 외부엔 비밀, 내부에서만 쓰는 까리한 로직.  
- **`api/`**: 5단계 클라우드화를 위한 준비, gRPC와 REST로 날아갈 예정! ✈️  
- **`test/`**: 모든 까리함을 테스트로 증명!  
- **`go.mod`**: Go 모듈로 시작, `go mod init github.com/jinhyeok/golite`로 출발!  

이 구조는 1단계부터 시작해서 5단계까지 자연스럽게 확장할 수 있어요. 까리함과 실용성을 동시에 잡았죠! 😎

---

## 🌈 GoLite의 미래
GoLite는 끝이 아니라 시작이에요! 앞으로:  
- 더 쿨한 자료구조 도입 (ART? Bw-Tree?)  
- 클라우드 배포 챌린지 (AWS? GCP?)  
- 실무에서 GoLite 써보기!  

GoLite와 함께 까리한 여정에 뛰어들고 싶다면, 언제든 아이디어 던져주세요! 🙌  

---

## 🎉 만든 사람
- **Jinhyeok**: Go와 DB를 사랑하는 까리한 엔지니어 🌟  
- 모토: "소프트웨어는 재미있어야 까리하다!" 😊  

---